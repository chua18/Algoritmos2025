# -*- coding: utf-8 -*-
"""Coordenadas_GIFs.ipynb

Automatically generated by Colab.

"""



import osmnx as ox
import networkx as nx
import random
import heapq
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import io
import os

# Variable global para almacenar frames
frames = []

# Cargar el grafo de Salto, Uruguay
place_name = "Salto, Uruguay"
G = ox.graph_from_place(place_name, network_type="drive")
G = ox.project_graph(G)  # üëà a√±ade esto

# Procesar atributos del grafo (velocidades, pesos, etc.)
for edge in G.edges:
    maxspeed = 40
    if "maxspeed" in G.edges[edge]:
        maxspeed = G.edges[edge]["maxspeed"]
        if type(maxspeed) == list:
            speeds = [int(speed) for speed in maxspeed]
            maxspeed = min(speeds)
        elif type(maxspeed) == str:
            maxspeed = int(maxspeed)
    G.edges[edge]["maxspeed"] = maxspeed
    G.edges[edge]["weight"] = G.edges[edge]["length"] / maxspeed

def style_unvisited_edge(edge):
    G.edges[edge]["color"] = "#d36206"
    G.edges[edge]["alpha"] = 0.2
    G.edges[edge]["linewidth"] = 0.5

def style_visited_edge(edge):
    G.edges[edge]["color"] = "#d36206"
    G.edges[edge]["alpha"] = 1
    G.edges[edge]["linewidth"] = 1

def style_active_edge(edge):
    G.edges[edge]["color"] = '#e8a900'
    G.edges[edge]["alpha"] = 1
    G.edges[edge]["linewidth"] = 1

def style_path_edge(edge):
    G.edges[edge]["color"] = "white"
    G.edges[edge]["alpha"] = 1
    G.edges[edge]["linewidth"] = 1

def plot_graph_to_image(title="", save_frame=False, frame_num=0):
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(12, 12), facecolor='#000000')
    ax.set_facecolor('#000000')
    ox.plot_graph(
        G,
        ax=ax,
        node_size=[G.nodes[node]["size"] for node in G.nodes],
        edge_color=[G.edges[edge]["color"] for edge in G.edges],
        edge_alpha=[G.edges[edge]["alpha"] for edge in G.edges],
        edge_linewidth=[G.edges[edge]["linewidth"] for edge in G.edges],
        node_color="white",
        bgcolor="#000000",
        show=False,
        close=False
    )
    clean_title = title.encode('ascii', 'ignore').decode('ascii')
    ax.set_title(clean_title, color='white', fontsize=16, pad=20)

    if save_frame:
        buf = io.BytesIO()
        plt.savefig(buf, format='png', bbox_inches='tight',
                    facecolor='#000000', edgecolor='none', dpi=100)
        buf.seek(0)
        img = Image.open(buf).copy()
        frames.append(img)
        buf.close()

    plt.close()
    return fig

def distance(node1, node2):
    x1, y1 = G.nodes[node1]["x"], G.nodes[node1]["y"]
    x2, y2 = G.nodes[node2]["x"], G.nodes[node2]["y"]
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

# ============================================================
# ALGORITMO DE DIJKSTRA
# ============================================================

def dijkstra_gif(orig, dest):
    global frames
    frames = []

    # Inicializaci√≥n: todos los nodos est√°n sin visitar y a distancia infinita
    for node in G.nodes:
        G.nodes[node]["visited"] = False
        G.nodes[node]["distance"] = float("inf")
        G.nodes[node]["previous"] = None
        G.nodes[node]["size"] = 0
    for edge in G.edges:
        style_unvisited_edge(edge)

    # El nodo origen tiene distancia 0
    G.nodes[orig]["distance"] = 0
    G.nodes[orig]["size"] = 50
    G.nodes[dest]["size"] = 50

    # Cola de prioridad: almacena (distancia_acumulada, nodo)
    pq = [(0, orig)]
    step = 0

    # Guardar frame inicial (para la animaci√≥n)
    plot_graph_to_image("Dijkstra - Inicio", save_frame=True, frame_num=0)

    # Bucle principal del algoritmo
    while pq:
        # Sacar el nodo con la menor distancia acumulada
        _, node = heapq.heappop(pq)

        # Si llegamos al destino, detenemos el algoritmo
        if node == dest:
            plot_graph_to_image(f"Dijkstra - Destino encontrado! (Iteraciones: {step})",
                                save_frame=True, frame_num=step+1)
            break

        # Si ya fue visitado, lo ignoramos
        if G.nodes[node]["visited"]:
            continue

        # Marcamos el nodo como visitado
        G.nodes[node]["visited"] = True

        # Exploramos sus vecinos
        for edge in G.out_edges(node):
            style_visited_edge((edge[0], edge[1], 0))  # Pintamos la arista explorada
            neighbor = edge[1]
            weight = G.edges[(edge[0], edge[1], 0)]["weight"]

            # Si encontramos un camino m√°s corto hacia el vecino, actualizamos
            if G.nodes[neighbor]["distance"] > G.nodes[node]["distance"] + weight:
                G.nodes[neighbor]["distance"] = G.nodes[node]["distance"] + weight
                G.nodes[neighbor]["previous"] = node
                # Insertamos en la cola con la nueva distancia
                heapq.heappush(pq, (G.nodes[neighbor]["distance"], neighbor))
                # Resaltamos los vecinos activos (en expansi√≥n)
                for edge2 in G.out_edges(neighbor):
                    style_active_edge((edge2[0], edge2[1], 0))

        step += 1

        # Guardar frame cada 10 pasos para no generar demasiadas im√°genes
        if step % 10 == 0:
            plot_graph_to_image(f"Dijkstra explorando... (Iteracion: {step})",
                                save_frame=True, frame_num=step)

    print(f"Dijkstra completado: {len(frames)} frames capturados")

# ============================================================
# ALGORITMO A*
# ============================================================

def a_star_gif(orig, dest):
    global frames
    frames = []

    # Inicializamos valores de cada nodo
    for node in G.nodes:
        G.nodes[node]["previous"] = None
        G.nodes[node]["size"] = 0
        G.nodes[node]["g_score"] = float("inf")  # costo desde el origen
        G.nodes[node]["f_score"] = float("inf")  # costo estimado total
    for edge in G.edges:
        style_unvisited_edge(edge)

    # Inicializamos el nodo origen
    G.nodes[orig]["size"] = 50
    G.nodes[dest]["size"] = 50
    G.nodes[orig]["g_score"] = 0
    # f = g + h ‚Üí h se calcula con la distancia euclidiana (heur√≠stica)
    G.nodes[orig]["f_score"] = distance(orig, dest)

    # Cola de prioridad: contiene (f_score, nodo)
    pq = [(G.nodes[orig]["f_score"], orig)]
    step = 0

    # Primer frame
    plot_graph_to_image("A* - Inicio", save_frame=True, frame_num=0)

    # Bucle principal del algoritmo A*
    while pq:
        # Tomamos el nodo con menor f_score
        _, node = heapq.heappop(pq)

        # Si llegamos al destino, terminamos
        if node == dest:
            plot_graph_to_image(f"A* - Destino encontrado! (Iteraciones: {step})",
                                save_frame=True, frame_num=step+1)
            break

        # Exploramos los vecinos del nodo actual
        for edge in G.out_edges(node):
            style_visited_edge((edge[0], edge[1], 0))
            neighbor = edge[1]

            # Costo real desde el origen hasta el vecino (g)
            tentative_g_score = G.nodes[node]["g_score"] + distance(node, neighbor)

            # Si encontramos un camino m√°s corto hacia el vecino
            if tentative_g_score < G.nodes[neighbor]["g_score"]:
                # Actualizamos su padre (para reconstruir el camino)
                G.nodes[neighbor]["previous"] = node
                G.nodes[neighbor]["g_score"] = tentative_g_score
                # f = g + h (h = distancia estimada al destino)
                G.nodes[neighbor]["f_score"] = tentative_g_score + distance(neighbor, dest)
                # Insertamos en la cola con prioridad f_score
                heapq.heappush(pq, (G.nodes[neighbor]["f_score"], neighbor))
                # Resaltamos los vecinos activos
                for edge2 in G.out_edges(neighbor):
                    style_active_edge((edge2[0], edge2[1], 0))

        step += 1

        # Guardamos un frame cada 5 pasos (A* suele ser m√°s r√°pido)
        if step % 5 == 0:
            plot_graph_to_image(f"A* explorando... (Iteracion: {step})",
                                save_frame=True, frame_num=step)

    print(f"A* completado: {len(frames)} frames capturados")

# ============================================================

def reconstruct_path_gif(orig, dest, algorithm_name=""):
    global frames

    # 1) Chequeo de que haya camino
    if G.nodes[dest].get("previous") is None and dest != orig:
        print("No se encontro un camino valido")
        return False

    # 2) Resetear estilos
    for edge in G.edges:
        style_unvisited_edge(edge)

    dist = 0.0
    speeds = []
    curr = dest
    path_edges = []

    # 3) Reconstruir el camino nodos ‚Üí aristas
    while curr != orig:
        prev = G.nodes[curr].get("previous")
        if prev is None:
            print("Error: Camino incompleto")
            return False

        edge_key = (prev, curr, 0)
        if edge_key not in G.edges:
            print(f"Arista {edge_key} no encontrada en el grafo")
            return False

        path_edges.append(edge_key)

        data = G.edges[edge_key]
        dist += data.get("length", 0.0)

        maxspeed = data.get("maxspeed")
        if isinstance(maxspeed, (int, float)):
            speeds.append(maxspeed)

        curr = prev

    # 4) Pintar el camino paso a paso
    for i, edge in enumerate(reversed(path_edges)):
        style_path_edge(edge)
        plot_graph_to_image(
            f"{algorithm_name} - Construyendo camino... {i+1}/{len(path_edges)}",
            save_frame=True,
            frame_num=i,
        )

    # 5) Calcular m√©tricas (sin dividir por cero)
    dist_km = dist / 1000.0 if dist > 0 else 0.0

    if speeds:
        vel_prom = sum(speeds) / len(speeds)
        tiempo_min = dist_km / vel_prom * 60.0 if vel_prom > 0 else 0.0
    else:
        # Caso borde: no hay velocidades registradas
        vel_prom = 0.0
        tiempo_min = 0.0

    # 6) T√≠tulo del √∫ltimo frame
    if vel_prom > 0:
        final_title = (
            f"{algorithm_name} - CAMINO OPTIMO\n"
            f"Distancia: {dist_km:.2f}km | "
            f"Velocidad: {vel_prom:.1f}km/h | "
            f"Tiempo: {tiempo_min:.1f}min"
        )
    else:
        final_title = (
            f"{algorithm_name} - CAMINO OPTIMO\n"
            f"Distancia: {dist_km:.2f}km"
        )

    plot_graph_to_image(final_title, save_frame=True, frame_num=len(path_edges))

    print(f"Distancia: {dist_km:.2f} km")
    if vel_prom > 0:
        print(f"Velocidad promedio: {vel_prom:.1f} km/h")
        print(f"Tiempo total: {tiempo_min:.1f} minutos")
    print(f"Camino completado: {len(frames)} frames totales")

    return True

def create_gif(algorithm_name, duration=500):
    if not frames:
        print("No hay frames para crear el GIF")
        return None
    filename = f"pathfinding_{algorithm_name.lower()}_salto.gif"
    try:
        frames[0].save(
            filename,
            save_all=True,
            append_images=frames[1:],
            duration=duration,
            loop=0
        )
        print(f"GIF creado exitosamente: {filename}")
        print(f"{len(frames)} frames | {len(frames)*duration/1000:.1f}s total")
        return filename
    except Exception as e:
        print(f"Error al crear el GIF: {e}")
        return None

def get_coordinates():
    print("SELECCION DE COORDENADAS PARA SALTO, URUGUAY")
    print("=" * 50)
    print("Algunas coordenadas de referencia en Salto:")
    print("   ‚Ä¢ Centro de Salto: -31.3833, -57.9667")
    print("   ‚Ä¢ Plaza Artigas: -31.3825, -57.9658")
    print("   ‚Ä¢ Hospital Regional: -31.3891, -57.9554")
    print("   ‚Ä¢ Terminal de Omnibus: -31.3878, -57.9640")
    print("   ‚Ä¢ Costanera Sur: -31.3795, -57.9525")
    print("   ‚Ä¢ Shopping Salto: -31.3715, -57.9580")

    while True:
        try:
            print("\nPUNTO DE ORIGEN:")
            start_lat = float(input("   Latitud (ej: -31.3833): "))
            start_lon = float(input("   Longitud (ej: -57.9667): "))
            print("\nPUNTO DE DESTINO:")
            end_lat = float(input("   Latitud (ej: -31.3825): "))
            end_lon = float(input("   Longitud (ej: -57.9658): "))
            if not (-31.45 <= start_lat <= -31.30 and -58.10 <= start_lon <= -57.85):
                print("Las coordenadas de origen parecen estar fuera de Salto")
                continue
            if not (-31.45 <= end_lat <= -31.30 and -58.10 <= end_lon <= -57.85):
                print("Las coordenadas de destino parecen estar fuera de Salto")
                continue
            return (start_lat, start_lon), (end_lat, end_lon)
        except ValueError:
            print("Por favor ingresa numeros validos (usa punto decimal, ej: -31.3833)")
        retry = input("\nQuieres intentar de nuevo? (s/n): ").lower()
        if retry != 's':
            print("Usando coordenadas por defecto...")
            return (-31.3833, -57.9667), (-31.3825, -57.9658)

if __name__ == "__main__":
    largest_cc = max(nx.strongly_connected_components(G), key=len)
    valid_nodes = list(largest_cc)
    start_coords, end_coords = get_coordinates()
    print("\nBuscando nodos mas cercanos a tus coordenadas...")
    start = ox.distance.nearest_nodes(G, start_coords[1], start_coords[0])
    end = ox.distance.nearest_nodes(G, end_coords[1], end_coords[0])
    if start not in valid_nodes:
        print("El punto de origen no esta en la red vial principal. Buscando alternativa...")
        start = min(valid_nodes, key=lambda n: ((G.nodes[n]['x'] - start_coords[1])**2 + (G.nodes[n]['y'] - start_coords[0])**2)**0.5)
    if end not in valid_nodes:
        print("El punto de destino no esta en la red vial principal. Buscando alternativa...")
        end = min(valid_nodes, key=lambda n: ((G.nodes[n]['x'] - end_coords[1])**2 + (G.nodes[n]['y'] - end_coords[0])**2)**0.5)
    print(f"\nCOORDENADAS SELECCIONADAS:")
    print(f"Origen: {start_coords[0]:.4f}, {start_coords[1]:.4f} ‚Üí Nodo {start}")
    print(f"Destino: {end_coords[0]:.4f}, {end_coords[1]:.4f} ‚Üí Nodo {end}")
    print(f"Usando {len(valid_nodes)} nodos conectados de Salto")
    print("\n" + "="*50)
    print("1Ô∏è‚É£ GENERANDO GIF DE DIJKSTRA")
    print("-" * 30)
    dijkstra_gif(start, end)
    if reconstruct_path_gif(start, end, "Dijkstra"):
        dijkstra_gif_file = create_gif("Dijkstra", duration=600)
    print("\n" + "="*50)
    print("2Ô∏è‚É£ GENERANDO GIF DE A*")
    print("-" * 30)
    a_star_gif(start, end)
    if reconstruct_path_gif(start, end, "A_Star"):
        astar_gif_file = create_gif("A_Star", duration=400)
    print("\n" + "="*20)
    print("GIFs generados exitosamente!")